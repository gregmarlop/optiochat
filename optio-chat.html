<!DOCTYPE html>
<!--
 * Optio Chat v3.0 - P2P Encrypted Chat
 * https://github.com/gregmarlop/optiochat
 * 
 * Encryption layers:
 * 1. AES-256-GCM (symmetric, unbreakable)
 * 2. LWE - Learning With Errors (lattice, post-quantum)
 * 3. MQ - Multivariate Quadratic (NP-hard)
 * 4. Subset Sum (NP-complete)
 * 5. Optio (classical cipher labyrinth)
 * 
 * MIT License - Copyright (c) 2026 Gregori M.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optio Chat</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #fff;
            font-family: 'IBM Plex Mono', 'Consolas', monospace;
            font-size: 13px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 15px;
        }
        .logo {
            text-align: center;
            font-size: 9px;
            color: #888;
            white-space: pre;
            margin-bottom: 15px;
        }
        .setup-container { max-width: 400px; margin: 0 auto; }
        .setup { text-align: center; }
        .setup h2 { color: #fff; font-size: 13px; margin-bottom: 15px; font-weight: normal; }
        .setup input {
            width: 100%;
            padding: 10px;
            background: #111;
            border: 1px solid #333;
            color: #fff;
            font-family: inherit;
            font-size: 13px;
            margin-bottom: 10px;
            text-align: center;
        }
        .setup input:focus { outline: none; border-color: #fff; }
        .setup .buttons { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        .setup button {
            padding: 10px 20px;
            background: #fff;
            color: #000;
            border: none;
            font-family: inherit;
            font-size: 13px;
            cursor: pointer;
        }
        .setup button:hover { background: #ccc; }
        .setup button.secondary { background: #000; color: #fff; border: 1px solid #fff; }
        .setup button.secondary:hover { background: #222; }
        .room-code {
            font-size: 20px;
            color: #fff;
            letter-spacing: 0.1em;
            margin: 15px 0;
            padding: 12px;
            border: 1px solid #333;
            background: #111;
        }
        .conn-status { margin-top: 15px; padding: 10px; border: 1px solid #333; font-size: 11px; }
        .conn-status .state { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .conn-status .dot { width: 8px; height: 8px; border-radius: 50%; background: #888; }
        .conn-status .dot.connecting { background: #aa0; animation: pulse 1s infinite; }
        .conn-status .dot.connected { background: #0a0; }
        .conn-status .dot.failed { background: #a00; }
        .conn-status .dot.reconnecting { background: #a50; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .conn-status .detail { color: #666; font-size: 10px; }
        .conn-status button { margin-top: 8px; padding: 6px 12px; background: #333; color: #fff; border: 1px solid #555; font-family: inherit; font-size: 11px; cursor: pointer; }
        .main-container { display: none; flex: 1; gap: 15px; max-width: 1000px; margin: 0 auto; width: 100%; }
        .main-container.active { display: flex; }
        @media (max-width: 700px) { .main-container { flex-direction: column; } .status-panel { order: -1; } }
        .chat-panel { flex: 1; display: flex; flex-direction: column; border: 1px solid #333; min-height: 400px; }
        .chat-header { padding: 8px 12px; border-bottom: 1px solid #333; color: #888; font-size: 11px; display: flex; justify-content: space-between; align-items: center; }
        .chat-header .conn-indicator { display: flex; align-items: center; gap: 6px; }
        .chat-header .conn-dot { width: 6px; height: 6px; border-radius: 50%; background: #0a0; }
        .chat-header .conn-dot.disconnected { background: #a00; }
        .chat-header .conn-dot.reconnecting { background: #a50; animation: pulse 1s infinite; }
        .messages { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 6px; }
        .message { max-width: 85%; padding: 6px 10px; font-size: 12px; line-height: 1.4; }
        .message.sent { align-self: flex-end; background: #fff; color: #000; }
        .message.received { align-self: flex-start; background: #222; color: #fff; border: 1px solid #333; }
        .message.system { align-self: center; color: #666; font-size: 10px; }
        .message.error { align-self: center; color: #a00; font-size: 10px; }
        .input-area { display: flex; gap: 8px; padding: 10px; border-top: 1px solid #333; }
        .input-area input { flex: 1; padding: 8px; background: #111; border: 1px solid #333; color: #fff; font-family: inherit; font-size: 13px; }
        .input-area input:focus { outline: none; border-color: #fff; }
        .input-area input:disabled { opacity: 0.5; }
        .input-area button { padding: 8px 15px; background: #fff; color: #000; border: none; font-family: inherit; cursor: pointer; font-size: 12px; }
        .input-area button:disabled { opacity: 0.5; cursor: not-allowed; }
        .status-panel { width: 280px; border: 1px solid #333; font-size: 11px; display: flex; flex-direction: column; }
        @media (max-width: 700px) { .status-panel { width: 100%; max-height: 200px; overflow-y: auto; } }
        .status-section { padding: 10px 12px; border-bottom: 1px solid #333; }
        .status-section:last-child { border-bottom: none; }
        .status-header { display: flex; justify-content: space-between; margin-bottom: 8px; color: #888; font-size: 10px; text-transform: uppercase; letter-spacing: 0.05em; }
        .status-badge { padding: 1px 6px; font-size: 9px; border-radius: 2px; }
        .status-badge.ok { background: #0a0; color: #000; }
        .status-badge.warn { background: #aa0; color: #000; }
        .status-badge.error { background: #a00; color: #fff; }
        .status-row { display: flex; justify-content: space-between; padding: 2px 0; color: #aaa; }
        .status-row .label { color: #666; }
        .status-row .value { color: #fff; }
        .status-check { padding: 2px 0; color: #0a0; }
        .status-check.warn { color: #aa0; }
        .status-check.error { color: #a00; }
        .crypto-layers { color: #888; font-size: 9px; margin-top: 4px; line-height: 1.4; }
        .debug-log { max-height: 100px; overflow-y: auto; font-size: 9px; color: #666; margin-top: 8px; padding-top: 8px; border-top: 1px solid #222; }
        .debug-log div { padding: 1px 0; }
        .debug-log .warn { color: #aa0; }
        .debug-log .error { color: #a00; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <pre class="logo">
 ▒█████   ██▓███  ▄▄▄█████▓ ██▓ ▒█████  
▒██▒  ██▒▓██░  ██▒▓  ██▒ ▓▒▓██▒▒██▒  ██▒
▒██░  ██▒▓██░ ██▓▒▒ ▓██░ ▒░▒██▒▒██░  ██▒
▒██   ██░▒██▄█▓▒ ▒░ ▓██▓ ░ ░██░▒██   ██░
░ ████▓▒░▒██▒ ░  ░  ▒██▒ ░ ░██░░ ████▓▒░
              CHAT v3.0</pre>

    <div class="setup-container" id="setup-start">
        <div class="setup">
            <h2>Encrypted P2P Chat</h2>
            <input type="password" id="secret-key" placeholder="Secret key (shared with peer)">
            <div class="buttons">
                <button onclick="createRoom()">CREATE ROOM</button>
                <button class="secondary" onclick="showJoin()">JOIN ROOM</button>
            </div>
        </div>
    </div>

    <div class="setup-container hidden" id="setup-waiting">
        <div class="setup">
            <h2>Share this code:</h2>
            <div class="room-code" id="room-code"></div>
            <div class="conn-status" id="waiting-status">
                <div class="state">
                    <div class="dot" id="waiting-dot"></div>
                    <span id="waiting-text">Waiting for peer...</span>
                </div>
                <div class="detail" id="waiting-detail"></div>
                <button onclick="cancelAndRetry()" id="waiting-retry" class="hidden">Retry</button>
            </div>
        </div>
    </div>

    <div class="setup-container hidden" id="setup-join">
        <div class="setup">
            <h2>Enter room code:</h2>
            <input type="text" id="join-code" placeholder="room-code">
            <div class="conn-status hidden" id="join-status">
                <div class="state">
                    <div class="dot" id="join-dot"></div>
                    <span id="join-text">Connecting...</span>
                </div>
                <div class="detail" id="join-detail"></div>
                <button onclick="cancelAndRetry()" id="join-retry" class="hidden">Retry</button>
            </div>
            <div class="buttons" id="join-buttons">
                <button onclick="joinRoom()">JOIN</button>
                <button class="secondary" onclick="showStart()">BACK</button>
            </div>
        </div>
    </div>

    <div class="main-container" id="main">
        <div class="chat-panel">
            <div class="chat-header">
                <span>Room: <span id="chat-room"></span></span>
                <div class="conn-indicator">
                    <div class="conn-dot" id="chat-conn-dot"></div>
                    <span id="chat-conn-text">Connected</span>
                </div>
            </div>
            <div class="messages" id="messages"></div>
            <div class="input-area">
                <input type="text" id="message-input" placeholder="Type message..." onkeypress="if(event.key==='Enter')sendMessage()" disabled>
                <button onclick="sendMessage()" id="send-btn" disabled>SEND</button>
            </div>
        </div>
        
        <div class="status-panel">
            <div class="status-section">
                <div class="status-header">
                    <span>Connection</span>
                    <span class="status-badge ok" id="conn-badge">OK</span>
                </div>
                <div class="status-row"><span class="label">Mode</span><span class="value" id="conn-mode">--</span></div>
                <div class="status-row"><span class="label">ICE</span><span class="value" id="conn-ice">--</span></div>
                <div class="status-row"><span class="label">Latency</span><span class="value" id="conn-latency">--</span></div>
                <div class="status-row"><span class="label">Uptime</span><span class="value" id="conn-uptime">--</span></div>
            </div>
            
            <div class="status-section">
                <div class="status-header">
                    <span>Security</span>
                    <span class="status-badge ok" id="sec-badge">OK</span>
                </div>
                <div class="status-check" id="sec-peer">✓ Peer stable</div>
                <div class="status-check" id="sec-decrypt">✓ No decrypt errors</div>
                <div class="status-check" id="sec-replay">✓ No replay detected</div>
                <div class="status-check" id="sec-latency">✓ Latency normal</div>
            </div>
            
            <div class="status-section">
                <div class="status-header">
                    <span>Crypto Stack</span>
                </div>
                <div class="status-row"><span class="label">Messages</span><span class="value"><span id="crypto-sent">0</span>↑ <span id="crypto-recv">0</span>↓</span></div>
                <div class="status-row"><span class="label">Bytes</span><span class="value"><span id="crypto-bytes-sent">0</span>↑ <span id="crypto-bytes-recv">0</span>↓</span></div>
                <div class="crypto-layers">
                    AES-256-GCM → LWE → MQ → SubsetSum → Optio
                </div>
            </div>
            
            <div class="status-section">
                <div class="status-header"><span>Debug</span></div>
                <div class="debug-log" id="debug-log"></div>
            </div>
        </div>
    </div>

    <script>
    // ============== CONFIG ==============
    const SIGNAL_SERVER = 'ws://localhost:3000';
    const ICE_SERVERS = [
        { urls: 'stun:stun.framasoft.org:3478' },
        { urls: 'stun:stun.stunprotocol.org:3478' },
        { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
        { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' }
    ];
    const CONNECTION_TIMEOUT = 30000;
    const RECONNECT_DELAYS = [1000, 2000, 4000, 8000, 15000, 30000];
    
    // ============== LAYER 1: AES-256-GCM ==============
    const AES_ITERATIONS = 100000;
    let aesKey = null;
    
    async function deriveAESKey(password, salt) {
        const enc = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']);
        return crypto.subtle.deriveKey(
            { name: 'PBKDF2', salt: enc.encode(salt), iterations: AES_ITERATIONS, hash: 'SHA-256' },
            keyMaterial,
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt', 'decrypt']
        );
    }
    
    async function aesEncrypt(plaintext) {
        const enc = new TextEncoder();
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, enc.encode(plaintext));
        const combined = new Uint8Array(iv.length + ciphertext.byteLength);
        combined.set(iv);
        combined.set(new Uint8Array(ciphertext), iv.length);
        return combined;
    }
    
    async function aesDecrypt(combined) {
        const iv = combined.slice(0, 12);
        const ciphertext = combined.slice(12);
        const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ciphertext);
        return new TextDecoder().decode(decrypted);
    }
    
    // ============== LAYER 2: LWE (Learning With Errors) ==============
    // Simplified LWE-inspired noise injection
    const LWE_N = 64;  // Dimension
    const LWE_Q = 257; // Prime modulus
    
    function lweGenerateMatrix(seed) {
        const r = prng(seed);
        const A = [];
        for (let i = 0; i < LWE_N; i++) {
            A[i] = [];
            for (let j = 0; j < LWE_N; j++) {
                A[i][j] = Math.floor(r() * LWE_Q);
            }
        }
        return A;
    }
    
    function lweGenerateError(seed, len) {
        const r = prng(seed);
        const e = [];
        // Gaussian-like small errors
        for (let i = 0; i < len; i++) {
            const u1 = r(), u2 = r();
            const z = Math.sqrt(-2 * Math.log(u1 + 0.0001)) * Math.cos(2 * Math.PI * u2);
            e[i] = Math.round(z * 2) % 5; // Small error in [-2, 2]
        }
        return e;
    }
    
    function lweEncrypt(data, keySeed) {
        const A = lweGenerateMatrix(keySeed);
        const s = lweGenerateError(keySeed + 1, LWE_N);
        const result = [];
        
        for (let i = 0; i < data.length; i++) {
            const e = lweGenerateError(keySeed + i + 2, 1)[0];
            let sum = data[i];
            for (let j = 0; j < LWE_N; j++) {
                sum += A[i % LWE_N][j] * s[j];
            }
            sum += e;
            result.push(((sum % LWE_Q) + LWE_Q) % LWE_Q);
        }
        return result;
    }
    
    function lweDecrypt(data, keySeed) {
        const A = lweGenerateMatrix(keySeed);
        const s = lweGenerateError(keySeed + 1, LWE_N);
        const result = [];
        
        for (let i = 0; i < data.length; i++) {
            let sum = data[i];
            for (let j = 0; j < LWE_N; j++) {
                sum -= A[i % LWE_N][j] * s[j];
            }
            // Round to nearest valid byte
            let val = ((sum % LWE_Q) + LWE_Q) % LWE_Q;
            if (val > 128) val = val - LWE_Q;
            result.push(((val % 256) + 256) % 256);
        }
        return result;
    }
    
    // ============== LAYER 3: MQ (Multivariate Quadratic) ==============
    const MQ_VARS = 8;
    
    function mqGenerateCoeffs(seed) {
        const r = prng(seed);
        const coeffs = [];
        // Quadratic terms + linear terms
        const numCoeffs = (MQ_VARS * (MQ_VARS + 1)) / 2 + MQ_VARS;
        for (let i = 0; i < numCoeffs; i++) {
            coeffs.push(Math.floor(r() * 256));
        }
        return coeffs;
    }
    
    function mqScramble(data, keySeed) {
        const coeffs = mqGenerateCoeffs(keySeed);
        const result = [];
        
        for (let i = 0; i < data.length; i += MQ_VARS) {
            const block = data.slice(i, i + MQ_VARS);
            while (block.length < MQ_VARS) block.push(0);
            
            let sum = 0;
            let idx = 0;
            // Quadratic terms
            for (let j = 0; j < MQ_VARS; j++) {
                for (let k = j; k < MQ_VARS; k++) {
                    sum += coeffs[idx++] * block[j] * block[k];
                }
            }
            // Linear terms
            for (let j = 0; j < MQ_VARS; j++) {
                sum += coeffs[idx++] * block[j];
            }
            
            // XOR with original to make reversible
            for (let j = 0; j < block.length; j++) {
                result.push(block[j] ^ ((sum >> (j * 3)) & 0xFF));
            }
        }
        return result;
    }
    
    function mqUnscramble(data, keySeed) {
        // Same operation is its own inverse (XOR based)
        return mqScramble(data, keySeed);
    }
    
    // ============== LAYER 4: SUBSET SUM ==============
    function subsetSumGenerateSet(seed, size) {
        const r = prng(seed);
        const set = [];
        for (let i = 0; i < size; i++) {
            set.push(Math.floor(r() * 256));
        }
        return set;
    }
    
    function subsetSumEncode(data, keySeed) {
        const set = subsetSumGenerateSet(keySeed, 16);
        const result = [];
        
        for (let i = 0; i < data.length; i++) {
            const byte = data[i];
            let encoded = 0;
            // Use byte bits to select subset elements
            for (let bit = 0; bit < 8; bit++) {
                if ((byte >> bit) & 1) {
                    encoded += set[bit];
                    encoded += set[8 + bit] * (i % 7 + 1); // Position-dependent
                }
            }
            result.push(encoded & 0xFF);
            result.push((encoded >> 8) & 0xFF);
        }
        return result;
    }
    
    function subsetSumDecode(data, keySeed) {
        const set = subsetSumGenerateSet(keySeed, 16);
        const result = [];
        
        for (let i = 0; i < data.length; i += 2) {
            const encoded = data[i] | (data[i + 1] << 8);
            const origIdx = i / 2;
            
            // Brute force decode (only 256 possibilities per byte)
            let bestByte = 0;
            let bestDiff = Infinity;
            
            for (let candidate = 0; candidate < 256; candidate++) {
                let sum = 0;
                for (let bit = 0; bit < 8; bit++) {
                    if ((candidate >> bit) & 1) {
                        sum += set[bit];
                        sum += set[8 + bit] * (origIdx % 7 + 1);
                    }
                }
                const diff = Math.abs((sum & 0xFFFF) - encoded);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestByte = candidate;
                }
            }
            result.push(bestByte);
        }
        return result;
    }
    
    // ============== LAYER 5: OPTIO (Classical Labyrinth) ==============
    const AU = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const AL = 'abcdefghijklmnopqrstuvwxyz';
    const A = AU + AL;
    let cipherOrder = [];

    function prng(s) {
        s = s >>> 0 || 1;
        return function() {
            s = (s + 0x6D2B79F5) >>> 0;
            let t = Math.imul(s ^ (s >>> 15), s | 1);
            t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
    }

    function seedFromKey(k) {
        let h = 0;
        for (let i = 0; i < k.length; i++) h = ((h << 5) - h + k.charCodeAt(i)) >>> 0;
        for (let i = 0; i < 10000; i++) {
            h = ((h << 5) - h + (h >>> 16)) >>> 0;
            h = (h ^ (h >>> 11)) >>> 0;
            h = ((h << 7) ^ h) >>> 0;
        }
        return h || 1;
    }

    function caesar(t, sh, inv) {
        const d = inv ? -sh : sh;
        return t.split('').map(c => {
            let i = AU.indexOf(c); if (i !== -1) return AU[(i + d + 26) % 26];
            i = AL.indexOf(c); if (i !== -1) return AL[(i + d + 26) % 26];
            return c;
        }).join('');
    }

    function atbash(t) {
        return t.split('').map(c => {
            let i = AU.indexOf(c); if (i !== -1) return AU[25 - i];
            i = AL.indexOf(c); if (i !== -1) return AL[25 - i];
            return c;
        }).join('');
    }

    function vigenere(t, k, inv) {
        let ki = 0;
        return t.split('').map(c => {
            let i = AU.indexOf(c), b = AU;
            if (i === -1) { i = AL.indexOf(c); b = AL; }
            if (i === -1) return c;
            const sh = AU.indexOf(k[ki++ % k.length].toUpperCase());
            return sh === -1 ? c : b[(i + (inv ? -sh : sh) + 26) % 26];
        }).join('');
    }

    function substitution(t, s, inv) {
        const r = prng(s);
        const ch = A.split('');
        for (let i = ch.length - 1; i > 0; i--) {
            const j = Math.floor(r() * (i + 1));
            [ch[i], ch[j]] = [ch[j], ch[i]];
        }
        if (!inv) return t.split('').map(c => { const i = A.indexOf(c); return i !== -1 ? ch[i] : c; }).join('');
        return t.split('').map(c => { const i = ch.indexOf(c); return i !== -1 ? A[i] : c; }).join('');
    }

    const OPTIO_METHODS = [
        { f: (t, p, i) => caesar(t, p.c1, i), p: r => ({ c1: 1 + Math.floor(r() * 25) }), name: 'Caesar' },
        { f: t => atbash(t), name: 'Atbash' },
        { f: (t, p, i, c) => vigenere(t, c, i), name: 'Vigenère' },
        { f: (t, p, i) => substitution(t, p.s1, i), p: r => ({ s1: Math.floor(r() * 1e6) }), name: 'Substitution' }
    ];

    function generateSalt() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let salt = ''; for (let i = 0; i < 8; i++) salt += chars[Math.floor(Math.random() * chars.length)];
        return salt;
    }

    function optioEncrypt(key, message) {
        const s = seedFromKey(key);
        const r = prng(s);
        const params = {};
        OPTIO_METHODS.forEach(m => { if (m.p) Object.assign(params, m.p(r)); });
        const order = [...OPTIO_METHODS];
        for (let i = order.length - 1; i > 0; i--) {
            const j = Math.floor(r() * (i + 1));
            [order[i], order[j]] = [order[j], order[i]];
        }
        cipherOrder = order.map(m => m.name);
        let res = generateSalt() + '\x00' + message;
        for (const m of order) res = m.f(res, params, false, key);
        return res;
    }

    function optioDecrypt(key, encrypted) {
        const s = seedFromKey(key);
        const r = prng(s);
        const params = {};
        OPTIO_METHODS.forEach(m => { if (m.p) Object.assign(params, m.p(r)); });
        const order = [...OPTIO_METHODS];
        for (let i = order.length - 1; i > 0; i--) {
            const j = Math.floor(r() * (i + 1));
            [order[i], order[j]] = [order[j], order[i]];
        }
        let res = encrypted;
        for (let i = order.length - 1; i >= 0; i--) res = order[i].f(res, params, true, key);
        const idx = res.indexOf('\x00');
        return idx !== -1 ? res.substring(idx + 1) : res;
    }
    
    // ============== COMBINED ENCRYPTION ==============
    async function initCrypto(password) {
        aesKey = await deriveAESKey(password, 'OptioChatV3Salt2026');
    }
    
    async function encrypt(key, message) {
        const keySeed = seedFromKey(key);
        
        // Layer 1: AES-256-GCM
        const aesResult = await aesEncrypt(message);
        let data = Array.from(aesResult);
        
        // Layer 2: LWE
        data = lweEncrypt(data, keySeed);
        
        // Layer 3: MQ
        data = mqScramble(data, keySeed + 1000);
        
        // Layer 4: Subset Sum
        data = subsetSumEncode(data, keySeed + 2000);
        
        // Layer 5: Optio
        const b64 = btoa(String.fromCharCode(...data));
        const optioResult = optioEncrypt(key, b64);
        
        return btoa(unescape(encodeURIComponent(optioResult)));
    }
    
    async function decrypt(key, encrypted) {
        try {
            const keySeed = seedFromKey(key);
            
            // Reverse Layer 5: Optio
            const optioEncrypted = decodeURIComponent(escape(atob(encrypted)));
            const b64 = optioDecrypt(key, optioEncrypted);
            let data = Array.from(atob(b64), c => c.charCodeAt(0));
            
            // Reverse Layer 4: Subset Sum
            data = subsetSumDecode(data, keySeed + 2000);
            
            // Reverse Layer 3: MQ
            data = mqUnscramble(data, keySeed + 1000);
            
            // Reverse Layer 2: LWE
            data = lweDecrypt(data, keySeed);
            
            // Reverse Layer 1: AES
            const message = await aesDecrypt(new Uint8Array(data));
            
            return message;
        } catch (e) {
            console.error('Decrypt error:', e);
            return null;
        }
    }

    // ============== STATE ==============
    let ws = null, pc = null, dc = null;
    let secretKey = '', roomCode = '', isHost = false;
    let connectionState = 'idle', reconnectAttempt = 0;
    let reconnectTimer = null, connectionTimer = null;
    let iceCandidateQueue = [], seenMessages = new Set();
    let makingOffer = false, ignoreOffer = false;
    
    let stats = { connectedAt: null, msgSent: 0, msgRecv: 0, bytesSent: 0, bytesRecv: 0, decryptErrors: 0, lastLatency: 0 };
    const debugLog = [];
    
    function debug(msg, level = 'info') {
        debugLog.push({ ts: new Date().toISOString().substr(11, 8), msg, level });
        if (debugLog.length > 50) debugLog.shift();
        const el = document.getElementById('debug-log');
        if (el) {
            el.innerHTML = debugLog.slice(-15).map(e => `<div class="${e.level}">${e.ts} ${e.msg}</div>`).join('');
            el.scrollTop = el.scrollHeight;
        }
        console.log(`[${level}] ${msg}`);
    }

    function generateRoomCode() {
        const words = ['sol','luna','mar','rio','nube','viento','fuego','tierra','luz','sombra','cafe','libro','mesa','arbol','piedra'];
        return `${words[Math.floor(Math.random()*words.length)]}-${words[Math.floor(Math.random()*words.length)]}-${Math.floor(Math.random()*100)}`;
    }

    function showStart() {
        document.getElementById('setup-start').classList.remove('hidden');
        document.getElementById('setup-waiting').classList.add('hidden');
        document.getElementById('setup-join').classList.add('hidden');
        document.getElementById('main').classList.remove('active');
    }
    function showJoin() {
        document.getElementById('setup-start').classList.add('hidden');
        document.getElementById('setup-join').classList.remove('hidden');
        document.getElementById('join-status').classList.add('hidden');
        document.getElementById('join-buttons').classList.remove('hidden');
    }
    function showChat() {
        document.getElementById('setup-start').classList.add('hidden');
        document.getElementById('setup-waiting').classList.add('hidden');
        document.getElementById('setup-join').classList.add('hidden');
        document.getElementById('main').classList.add('active');
        document.getElementById('chat-room').textContent = roomCode;
        enableChat(true);
        stats.connectedAt = Date.now();
        setInterval(updateStats, 1000);
        startPing();
    }
    function enableChat(enabled) {
        document.getElementById('message-input').disabled = !enabled;
        document.getElementById('send-btn').disabled = !enabled;
        if (enabled) document.getElementById('message-input').focus();
    }
    function addMessage(text, type) {
        const div = document.createElement('div');
        div.className = 'message ' + type;
        div.textContent = text;
        document.getElementById('messages').appendChild(div);
        div.scrollIntoView({ behavior: 'smooth' });
    }
    function updateConnectionUI(state, detail = '') {
        connectionState = state;
        const dots = ['waiting-dot','join-dot','chat-conn-dot'].map(id => document.getElementById(id)).filter(Boolean);
        dots.forEach(d => d.className = d.id === 'chat-conn-dot' ? 'conn-dot' : 'dot');
        
        const states = { connecting: 'connecting', waiting: 'connecting', connected: 'connected', reconnecting: 'reconnecting', failed: 'failed' };
        dots.forEach(d => d.classList.add(states[state] || ''));
        
        const texts = { connecting: 'Connecting...', waiting: 'Waiting for peer...', connected: 'Connected', reconnecting: `Reconnecting (${reconnectAttempt})...`, failed: 'Connection failed' };
        ['waiting-text','join-text','chat-conn-text'].forEach(id => { const el = document.getElementById(id); if (el) el.textContent = texts[state] || state; });
        
        if (detail) ['waiting-detail','join-detail'].forEach(id => { const el = document.getElementById(id); if (el) el.textContent = detail; });
        
        document.getElementById('conn-mode').textContent = state === 'connected' ? 'P2P Direct' : state;
        const badge = document.getElementById('conn-badge');
        if (state === 'connected') { badge.textContent = 'OK'; badge.className = 'status-badge ok'; }
        else if (state === 'failed') { badge.textContent = 'OFF'; badge.className = 'status-badge error'; }
        else { badge.textContent = 'WAIT'; badge.className = 'status-badge warn'; }
        
        enableChat(state === 'connected');
    }

    function updateStats() {
        if (stats.connectedAt) {
            const secs = Math.floor((Date.now() - stats.connectedAt) / 1000);
            document.getElementById('conn-uptime').textContent = `${Math.floor(secs/60)}m ${secs%60}s`;
        }
        document.getElementById('crypto-sent').textContent = stats.msgSent;
        document.getElementById('crypto-recv').textContent = stats.msgRecv;
        document.getElementById('crypto-bytes-sent').textContent = stats.bytesSent < 1024 ? stats.bytesSent + 'b' : (stats.bytesSent/1024).toFixed(1) + 'kb';
        document.getElementById('crypto-bytes-recv').textContent = stats.bytesRecv < 1024 ? stats.bytesRecv + 'b' : (stats.bytesRecv/1024).toFixed(1) + 'kb';
        if (stats.lastLatency > 0) document.getElementById('conn-latency').textContent = stats.lastLatency + 'ms';
        if (pc) document.getElementById('conn-ice').textContent = pc.iceConnectionState || '--';
        
        const secBadge = document.getElementById('sec-badge');
        if (stats.decryptErrors === 0) { secBadge.textContent = 'OK'; secBadge.className = 'status-badge ok'; }
        else { secBadge.textContent = 'WARN'; secBadge.className = 'status-badge warn'; }
    }

    let pingInterval = null, pendingPing = null;
    function startPing() {
        if (pingInterval) clearInterval(pingInterval);
        pingInterval = setInterval(() => {
            if (dc && dc.readyState === 'open') {
                pendingPing = Date.now();
                try { dc.send(JSON.stringify({ type: 'ping', t: pendingPing })); } catch(e) {}
            }
        }, 5000);
    }
    function handlePing(data) {
        if (data.type === 'ping') try { dc.send(JSON.stringify({ type: 'pong', t: data.t })); } catch(e) {}
        else if (data.type === 'pong' && pendingPing) { stats.lastLatency = Date.now() - data.t; pendingPing = null; }
    }

    function cleanup() {
        debug('Cleaning up...');
        [connectionTimer, reconnectTimer, pingInterval].forEach(t => { if (t) clearInterval(t) || clearTimeout(t); });
        connectionTimer = reconnectTimer = pingInterval = null;
        if (dc) { dc.onopen = dc.onclose = dc.onmessage = dc.onerror = null; try { dc.close(); } catch(e) {} dc = null; }
        if (pc) { pc.onicecandidate = pc.oniceconnectionstatechange = pc.ondatachannel = pc.onnegotiationneeded = null; try { pc.close(); } catch(e) {} pc = null; }
        if (ws) { ws.onopen = ws.onclose = ws.onmessage = ws.onerror = null; try { ws.close(); } catch(e) {} ws = null; }
        iceCandidateQueue = []; makingOffer = ignoreOffer = false;
    }
    function cancelAndRetry() { cleanup(); reconnectAttempt = 0; showStart(); }

    function connectSignal() {
        return new Promise((resolve, reject) => {
            debug('Connecting to signal server...');
            ws = new WebSocket(SIGNAL_SERVER);
            const timeout = setTimeout(() => reject(new Error('Signal server timeout')), 10000);
            ws.onopen = () => { clearTimeout(timeout); debug('Signal connected'); resolve(); };
            ws.onerror = () => { clearTimeout(timeout); debug('Signal error', 'error'); reject(new Error('Cannot connect')); };
            ws.onclose = () => { debug('Signal disconnected', 'warn'); if (connectionState === 'connecting' || connectionState === 'waiting') updateConnectionUI('failed', 'Signal disconnected'); };
            ws.onmessage = (e) => { try { handleSignalMessage(JSON.parse(e.data)); } catch(err) { debug('Invalid signal', 'error'); } };
        });
    }

    async function handleSignalMessage(msg) {
        debug(`Signal: ${msg.type}`);
        if (msg.type === 'created') updateConnectionUI('waiting');
        else if (msg.type === 'joined') { updateConnectionUI('connecting', 'Establishing P2P...'); await startWebRTC(false); }
        else if (msg.type === 'peer-joined') { updateConnectionUI('connecting', 'Peer joined...'); await startWebRTC(true); }
        else if (msg.type === 'signal') await handleWebRTCSignal(msg.data);
        else if (msg.type === 'peer-left') { debug('Peer left', 'warn'); addMessage('Peer disconnected', 'system'); if (connectionState === 'connected') attemptReconnect(); }
        else if (msg.type === 'ping') ws.send(JSON.stringify({ type: 'pong' }));
        else if (msg.type === 'error') { debug(`Error: ${msg.message}`, 'error'); updateConnectionUI('failed', msg.message); }
    }

    async function startWebRTC(initiator) {
        debug(`Starting WebRTC (initiator: ${initiator})`);
        pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
        connectionTimer = setTimeout(() => { if (connectionState !== 'connected') { debug('Connection timeout', 'error'); updateConnectionUI('failed', 'Timeout'); attemptReconnect(); } }, CONNECTION_TIMEOUT);
        pc.onicecandidate = (e) => { if (e.candidate && ws?.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: 'signal', data: { ice: e.candidate } })); };
        pc.oniceconnectionstatechange = () => {
            debug(`ICE: ${pc.iceConnectionState}`);
            if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') { if (connectionTimer) { clearTimeout(connectionTimer); connectionTimer = null; } }
            else if (pc.iceConnectionState === 'failed') { debug('ICE failed', 'warn'); pc.restartIce(); }
            else if (pc.iceConnectionState === 'disconnected') setTimeout(() => { if (pc?.iceConnectionState === 'disconnected') attemptReconnect(); }, 3000);
        };
        pc.ondatachannel = (e) => { dc = e.channel; setupDataChannel(); };
        pc.onnegotiationneeded = async () => {
            try { makingOffer = true; await pc.setLocalDescription(); ws.send(JSON.stringify({ type: 'signal', data: { sdp: pc.localDescription } })); }
            catch(e) { debug('Negotiation error', 'error'); }
            finally { makingOffer = false; }
        };
        if (initiator) { dc = pc.createDataChannel('chat', { ordered: true }); setupDataChannel(); }
    }

    async function handleWebRTCSignal(data) {
        if (!pc) return;
        try {
            if (data.sdp) {
                const desc = new RTCSessionDescription(data.sdp);
                const collision = desc.type === 'offer' && (makingOffer || pc.signalingState !== 'stable');
                ignoreOffer = !isHost && collision;
                if (ignoreOffer) { debug('Ignoring collision'); return; }
                await pc.setRemoteDescription(desc);
                while (iceCandidateQueue.length) await pc.addIceCandidate(iceCandidateQueue.shift());
                if (desc.type === 'offer') { await pc.setLocalDescription(); ws.send(JSON.stringify({ type: 'signal', data: { sdp: pc.localDescription } })); }
            }
            if (data.ice) {
                if (pc.remoteDescription) await pc.addIceCandidate(new RTCIceCandidate(data.ice));
                else { debug('Queuing ICE'); iceCandidateQueue.push(new RTCIceCandidate(data.ice)); }
            }
        } catch(e) { if (!ignoreOffer) debug('Signal error: ' + e.message, 'error'); }
    }

    function attemptReconnect() {
        if (reconnectAttempt >= RECONNECT_DELAYS.length) { debug('Max reconnects', 'error'); updateConnectionUI('failed', 'Connection lost'); return; }
        const delay = RECONNECT_DELAYS[reconnectAttempt++];
        debug(`Reconnecting in ${delay}ms...`, 'warn');
        updateConnectionUI('reconnecting');
        cleanup();
        reconnectTimer = setTimeout(async () => {
            try { await connectSignal(); ws.send(JSON.stringify({ type: 'join', room: roomCode })); }
            catch(e) { debug('Reconnect failed', 'error'); attemptReconnect(); }
        }, delay);
    }

    function setupDataChannel() {
        dc.onopen = () => {
            debug('Connected!');
            if (connectionTimer) { clearTimeout(connectionTimer); connectionTimer = null; }
            reconnectAttempt = 0;
            updateConnectionUI('connected');
            showChat();
            addMessage('Connected. 5-layer encryption active.', 'system');
            addMessage('AES-256 → LWE → MQ → SubsetSum → Optio', 'system');
            if (ws) { ws.close(); ws = null; }
        };
        dc.onmessage = async (e) => {
            try { const data = JSON.parse(e.data); if (data.type === 'ping' || data.type === 'pong') { handlePing(data); return; } } catch {}
            const hash = e.data.substring(0, 20);
            if (seenMessages.has(hash)) { document.getElementById('sec-replay').textContent = '⚠ Replay!'; document.getElementById('sec-replay').className = 'status-check error'; return; }
            seenMessages.add(hash);
            if (seenMessages.size > 1000) seenMessages = new Set(Array.from(seenMessages).slice(-500));
            const decrypted = await decrypt(secretKey, e.data);
            stats.bytesRecv += e.data.length;
            if (decrypted) { stats.msgRecv++; addMessage(decrypted, 'received'); }
            else { stats.decryptErrors++; document.getElementById('sec-decrypt').textContent = '⚠ Decrypt errors: ' + stats.decryptErrors; document.getElementById('sec-decrypt').className = 'status-check warn'; addMessage('[decrypt error]', 'error'); }
        };
        dc.onclose = () => { debug('Channel closed', 'warn'); if (connectionState === 'connected') attemptReconnect(); };
        dc.onerror = () => debug('Channel error', 'error');
    }

    async function createRoom() {
        secretKey = document.getElementById('secret-key').value;
        if (!secretKey || secretKey.length < 4) return alert('Secret key min 4 chars');
        cleanup();
        updateConnectionUI('connecting', 'Initializing crypto...');
        try {
            await initCrypto(secretKey);
            debug('Crypto initialized');
            await connectSignal();
            roomCode = generateRoomCode();
            isHost = true;
            ws.send(JSON.stringify({ type: 'create', room: roomCode }));
            document.getElementById('room-code').textContent = roomCode;
            document.getElementById('setup-start').classList.add('hidden');
            document.getElementById('setup-waiting').classList.remove('hidden');
        } catch(e) { debug('Error: ' + e.message, 'error'); updateConnectionUI('failed', e.message); }
    }

    async function joinRoom() {
        secretKey = document.getElementById('secret-key').value;
        roomCode = document.getElementById('join-code').value.trim().toLowerCase();
        if (!secretKey || secretKey.length < 4) return alert('Secret key min 4 chars');
        if (!roomCode) return alert('Enter room code');
        cleanup();
        document.getElementById('join-buttons').classList.add('hidden');
        document.getElementById('join-status').classList.remove('hidden');
        updateConnectionUI('connecting', 'Initializing crypto...');
        try {
            await initCrypto(secretKey);
            debug('Crypto initialized');
            await connectSignal();
            isHost = false;
            ws.send(JSON.stringify({ type: 'join', room: roomCode }));
        } catch(e) { debug('Error: ' + e.message, 'error'); updateConnectionUI('failed', e.message); }
    }

    async function sendMessage() {
        const input = document.getElementById('message-input');
        const msg = input.value.trim();
        if (!msg || !dc || dc.readyState !== 'open') return;
        try {
            const encrypted = await encrypt(secretKey, msg);
            dc.send(encrypted);
            stats.msgSent++;
            stats.bytesSent += encrypted.length;
            addMessage(msg, 'sent');
            input.value = '';
        } catch(e) { debug('Send error: ' + e.message, 'error'); addMessage('[send failed]', 'error'); }
    }

    debug('Optio Chat v3.0 - 5-layer encryption');
    </script>
</body>
</html>
